<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Conference Timer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', 'Consolas', 'Monaco', monospace;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            overflow: hidden;
        }

        #timer {
            font-weight: bold;
            text-align: center;
            line-height: 0.9;
            white-space: nowrap;
        }

        #label {
            font-weight: normal;
            text-align: center;
            margin-bottom: 2vh;
            opacity: 0.8;
            white-space: nowrap;
        }

        #message {
            font-weight: normal;
            text-align: center;
            margin-top: 3vh;
            opacity: 0;
            white-space: pre-wrap;
            word-wrap: break-word;
            transform: translateY(-20px);
            transition: opacity 0.5s ease, transform 0.5s ease;
            max-height: 0;
            overflow: hidden;
        }

        #message.visible {
            opacity: 0.9;
            transform: translateY(0);
            max-height: 500px;
        }

        .container {
            text-align: center;
            max-width: 95vw;
            padding: 0 2vw;
        }

        #timer, #label {
            overflow: hidden;
            text-overflow: clip;
        }

        .warning {
            animation: pulse 1s ease-in-out infinite;
        }

        .flashing {
            animation: flash 0.5s ease-in-out;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }

        @keyframes flash {
            0%, 100% { opacity: 1; transform: scale(1); }
            25% { opacity: 0.3; transform: scale(1.05); }
            50% { opacity: 1; transform: scale(1); }
            75% { opacity: 0.3; transform: scale(1.05); }
        }

        #gameOverOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 9999;
            pointer-events: none;
            background: rgba(0, 0, 0, 0.85);
        }

        #gameOverOverlay.active {
            display: flex;
        }

        #gameOverText {
            font-size: 20vw;
            font-weight: bold;
            text-align: center;
            letter-spacing: 0.1em;
            text-shadow:
                0 0 20px rgba(255, 0, 0, 0.8),
                0 0 40px rgba(255, 0, 0, 0.6),
                0 0 60px rgba(255, 0, 0, 0.4);
            animation: gameOverFlash 0.8s ease-in-out infinite;
        }

        @keyframes gameOverFlash {
            0%, 100% {
                opacity: 1;
                color: #ff0000;
                transform: scale(1);
            }
            50% {
                opacity: 0.3;
                color: #ffffff;
                transform: scale(1.02);
            }
        }

        .controls {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            display: flex;
            gap: 10px;
        }

        .controls button {
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            background: #4CAF50;
            color: white;
            cursor: pointer;
            font-size: 14px;
        }

        .controls button:hover {
            background: #45a049;
        }

        .controls button.stop {
            background: #f44336;
        }

        .controls button.stop:hover {
            background: #da190b;
        }

        .controls button.reset {
            background: #2196F3;
        }

        .controls button.reset:hover {
            background: #0b7dda;
        }

        .blink-colon {
            animation: blink 1s step-end infinite;
        }

        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0; }
        }
    </style>
</head>
<body>
    <div class="container">
        <div id="label"></div>
        <div id="timer">00:00</div>
        <div id="message"></div>
    </div>

    <div id="gameOverOverlay">
        <div id="gameOverText">GAME OVER</div>
    </div>

    <div class="controls" id="controls">
        <button id="startBtn" onclick="startTimer()">Start</button>
        <button id="pauseBtn" onclick="pauseTimer()" style="display: none;">Pause</button>
        <button class="stop" onclick="stopTimer()">Stop</button>
        <button class="reset" onclick="resetTimer()">Reset</button>
    </div>

    <script>
        const urlParams = new URLSearchParams(window.location.search);

        function parseTime(value, defaultSeconds) {
            if (!value) return defaultSeconds;

            if (value.includes(':')) {
                const parts = value.split(':').map(p => parseInt(p) || 0);
                if (parts.length === 2) {
                    return parts[0] * 60 + parts[1];
                } else if (parts.length === 3) {
                    return parts[0] * 3600 + parts[1] * 60 + parts[2];
                }
            }

            return parseInt(value) || defaultSeconds;
        }

        const config = {
            duration: parseTime(urlParams.get('duration'), 600),
            mode: urlParams.get('mode') || 'countdown',
            fontSize: urlParams.get('fontSize') || '25vw',
            labelSize: urlParams.get('labelSize') || '6vw',
            messageSize: urlParams.get('messageSize') || '5vw',
            color: urlParams.get('color') || '#ffffff',
            warningColor: urlParams.get('warningColor') || '#ff9800',
            dangerColor: urlParams.get('dangerColor') || '#f44336',
            backgroundColor: urlParams.get('bg') || 'transparent',
            warningTime: parseTime(urlParams.get('warningTime'), 60),
            dangerTime: parseTime(urlParams.get('dangerTime'), 30),
            label: urlParams.get('label') || '',
            hideControls: urlParams.get('hideControls') === 'true',
            countUp: urlParams.get('countUp') === 'true'
        };

        document.body.style.backgroundColor = config.backgroundColor;
        document.getElementById('timer').style.fontSize = config.fontSize;
        document.getElementById('timer').style.color = config.color;
        document.getElementById('label').style.fontSize = config.labelSize;
        document.getElementById('label').style.color = config.color;
        document.getElementById('label').textContent = config.label;
        document.getElementById('message').style.fontSize = config.messageSize;
        document.getElementById('message').style.color = config.color;

        if (config.hideControls) {
            const controls = document.getElementById('controls');
            if (controls) {
                controls.style.display = 'none';
            }
        }

        function adjustFontSize() {
            const timerElement = document.getElementById('timer');
            const container = document.querySelector('.container');

            let currentSize = parseFloat(window.getComputedStyle(timerElement).fontSize);

            while (timerElement.scrollWidth > window.innerWidth * 0.95 && currentSize > 10) {
                currentSize -= 1;
                timerElement.style.fontSize = currentSize + 'px';
            }
        }

        const defaultState = {
            isRunning: false,
            timeRemaining: config.duration,
            timeElapsed: 0,
            mode: config.mode,
            countUp: config.countUp,
            duration: config.duration,
            message: '',
            flashSignal: 0,
            gameOver: false
        };

        let latestState = { ...defaultState };
        let lastFlashSignal = 0;
        let channel = null;
        let clockInterval = null;

        function formatTime(seconds) {
            const isNegative = seconds < 0;
            const absSeconds = Math.abs(seconds);

            const hrs = Math.floor(absSeconds / 3600);
            const mins = Math.floor((absSeconds % 3600) / 60);
            const secs = absSeconds % 60;

            let timeString;
            if (hrs > 0) {
                timeString = `${hrs.toString().padStart(2, '0')}<span class="blink-colon">:</span>${mins.toString().padStart(2, '0')}<span class="blink-colon">:</span>${secs.toString().padStart(2, '0')}`;
            } else {
                timeString = `${mins.toString().padStart(2, '0')}<span class="blink-colon">:</span>${secs.toString().padStart(2, '0')}`;
            }

            return isNegative ? `-${timeString}` : timeString;
        }

        function formatClock() {
            const now = new Date();
            const hrs = now.getHours().toString().padStart(2, '0');
            const mins = now.getMinutes().toString().padStart(2, '0');
            return `${hrs}<span class="blink-colon">:</span>${mins}`;
        }

        function getEffectiveMode() {
            return typeof latestState.mode === 'string' ? latestState.mode : config.mode;
        }

        function isCountUpMode() {
            return typeof latestState.countUp === 'boolean' ? latestState.countUp : config.countUp;
        }

        function updateControlsVisibility() {
            const controls = document.getElementById('controls');
            if (!controls) return;

            if (config.hideControls || getEffectiveMode() === 'clock') {
                controls.style.display = 'none';
            } else {
                controls.style.display = '';
            }
        }

        function updateControlsState() {
            const startBtn = document.getElementById('startBtn');
            const pauseBtn = document.getElementById('pauseBtn');
            if (!startBtn || !pauseBtn) return;

            if (latestState.isRunning) {
                startBtn.style.display = 'none';
                pauseBtn.style.display = 'inline-block';
            } else {
                startBtn.style.display = 'inline-block';
                pauseBtn.style.display = 'none';
            }
        }

        function updateDisplay() {
            const timerElement = document.getElementById('timer');
            const mode = getEffectiveMode();

            if (mode === 'clock') {
                timerElement.innerHTML = formatClock();
                timerElement.style.color = config.color;
                timerElement.classList.remove('warning');
            } else if (isCountUpMode()) {
                const elapsed = typeof latestState.timeElapsed === 'number' ? latestState.timeElapsed : 0;
                timerElement.innerHTML = formatTime(elapsed);
                timerElement.style.color = config.color;
                timerElement.classList.remove('warning');
            } else {
                const remaining = typeof latestState.timeRemaining === 'number' ? latestState.timeRemaining : config.duration;
                timerElement.innerHTML = formatTime(remaining);

                if (remaining <= 0) {
                    timerElement.style.color = config.dangerColor;
                    timerElement.classList.add('warning');
                } else if (remaining <= config.dangerTime) {
                    timerElement.style.color = config.dangerColor;
                    timerElement.classList.add('warning');
                } else if (remaining <= config.warningTime) {
                    timerElement.style.color = config.warningColor;
                    timerElement.classList.remove('warning');
                } else {
                    timerElement.style.color = config.color;
                    timerElement.classList.remove('warning');
                }
            }

            adjustFontSize();
        }

        function updateMessageDisplay() {
            const messageEl = document.getElementById('message');
            if (!messageEl) return;
            const message = (latestState.message || '').trim();
            messageEl.textContent = message;
            if (message) {
                messageEl.classList.add('visible');
            } else {
                messageEl.classList.remove('visible');
            }
        }

        function updateGameOverOverlay() {
            const overlay = document.getElementById('gameOverOverlay');
            if (!overlay) return;
            if (latestState.gameOver) {
                overlay.classList.add('active');
            } else {
                overlay.classList.remove('active');
            }
        }

        function runFlashAnimation() {
            const timerEl = document.getElementById('timer');
            if (!timerEl) return;

            timerEl.classList.add('flashing');
            let flashCount = 0;
            const flashInterval = setInterval(() => {
                flashCount++;
                timerEl.classList.remove('flashing');
                void timerEl.offsetWidth;
                timerEl.classList.add('flashing');

                if (flashCount >= 5) {
                    clearInterval(flashInterval);
                    timerEl.classList.remove('flashing');
                }
            }, 500);
        }

        function handleFlash(signal) {
            if (typeof signal !== 'number') {
                return;
            }

            if (signal !== lastFlashSignal) {
                lastFlashSignal = signal;
                runFlashAnimation();
            }
        }

        function ensureClockInterval() {
            if (getEffectiveMode() === 'clock') {
                if (!clockInterval) {
                    clockInterval = setInterval(updateDisplay, 1000);
                }
            } else if (clockInterval) {
                clearInterval(clockInterval);
                clockInterval = null;
            }
        }

        function applyState(state) {
            latestState = { ...latestState, ...state };
            updateDisplay();
            updateControlsState();
            updateControlsVisibility();
            updateMessageDisplay();
            updateGameOverOverlay();
            handleFlash(latestState.flashSignal);
            ensureClockInterval();
        }

        function sendCommand(command, value = null) {
            if (channel) {
                channel.postMessage({ type: 'command', command, value });
            }
        }

        function startTimer() {
            sendCommand('start');
        }

        function pauseTimer() {
            sendCommand('pause');
        }

        function stopTimer() {
            sendCommand('stop');
        }

        function resetTimer() {
            sendCommand('reset');
        }

        function sendHeartbeat() {
            if (channel) {
                channel.postMessage({ type: 'display-heartbeat' });
            }
        }

        try {
            channel = new BroadcastChannel('timer-control');

            channel.onmessage = (event) => {
                const data = event.data;
                if (data && data.type === 'state') {
                    applyState(data);
                }
            };

            sendHeartbeat();
            setInterval(sendHeartbeat, 2000);
        } catch (e) {
            console.log('BroadcastChannel not available');
        }

        updateDisplay();
        updateControlsState();
        updateControlsVisibility();
        updateMessageDisplay();
        updateGameOverOverlay();
        ensureClockInterval();

        window.addEventListener('resize', () => {
            const timerElement = document.getElementById('timer');
            timerElement.style.fontSize = config.fontSize;
            adjustFontSize();
        });
    </script>
</body>
</html>

